/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f4xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


int main(void)
{
	//omogocimo porta a in g
	SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOAEN);
	SET_BIT(RCC->AHB1ENR, RCC_AHB1ENR_GPIOGEN);


	//clearamo 31 bit na 0 da mamo inout output mode
	//moram naredit 286 set pa reset bit

	SET_BIT(GPIOG->MODER, 1 << 30);
	CLEAR_BIT(GPIOG->MODER, 1 << 31);

	SET_BIT(GPIOG->MODER, 1 << 28);
	CLEAR_BIT(GPIOG->MODER, 1 << 29);

	SET_BIT(GPIOG->MODER, 1 << 26);
	CLEAR_BIT(GPIOG->MODER, 1 << 27);

	SET_BIT(GPIOG->MODER, 1 << 24);
	CLEAR_BIT(GPIOG->MODER, 1 << 25);

	SET_BIT(GPIOG->MODER, 1 << 22);
	CLEAR_BIT(GPIOG->MODER, 1 << 23);

	SET_BIT(GPIOG->MODER, 1 << 20);
	CLEAR_BIT(GPIOG->MODER, 1 << 21);

	SET_BIT(GPIOG->MODER, 1 << 18);
	CLEAR_BIT(GPIOG->MODER, 1 << 19);

	SET_BIT(GPIOG->MODER, 1 << 16);
	CLEAR_BIT(GPIOG->MODER, 1 << 17);

	SET_BIT(GPIOG->MODER, 1 << 14);
	CLEAR_BIT(GPIOG->MODER, 1 << 15);

	SET_BIT(GPIOG->MODER, 1 << 12);
	CLEAR_BIT(GPIOG->MODER, 1 << 13);


	int32_t stanjeGumba;
	int32_t stanjeGumba2;
	int polozaj = 1; //to je polozaj kje se nahajamo na ekratnu
	int faktor = 0;
	int running = 0;

	/* Loop forever */
	for(;;){
		//beremo gumb
		stanjeGumba = READ_BIT(GPIOA->IDR, GPIO_IDR_IDR_0);//vraca 1 ker je zadnji bit ce bi bil 32 bi vracalo 32

		//for(int i = 0; i< 500; i++){//delay
			//for(int j = 0; j<500;j++);
		//}
		//stanjeGumba2 = READ_BIT(GPIOA->IDR, GPIO_IDR_IDR_0);
			//ISCEMO 01 KOMBINACIJO TO POMENI DA SMO AKTIVIRALI
			//IZ STANJA NE STISNJENO V STISNJENO
		if(stanjeGumba == 1 && stanjeGumba2 == 0){ // ce je 0 = 1-1

			running = 1;
			faktor++;
		}
		stanjeGumba2 = stanjeGumba;

		if(faktor>3)
			faktor = 1;

		if(running){

			for(int i = 0; i< 1000/faktor; i++){//delay
				for(int j = 0; j<1000/faktor;j++);
			}
			//faktor++; //pristejemo faktor
			//in da delamo nas switch case in vedno preverjamo ce se je gumb se enkrat pritisnil,
			// ce se je gremo izven game loopa in

				switch(polozaj){
									case 1:
										SET_BIT(GPIOG->BSRRL, 1<<15);
										//zaj bi se clearali prejsne bite
										polozaj++;
										break;
									case 2://vklopi prvi dve
										SET_BIT(GPIOG->BSRRL, 1<<14);
										polozaj++;
										break;
									case 3://ko smo na tretjem polozaju moramo ze 3 meti prizgane
										SET_BIT(GPIOG->BSRRL, 1<<13);
										polozaj++;
										break;
									case 4:
										SET_BIT(GPIOG->BSRRH, 1<<15);
										SET_BIT(GPIOG->BSRRL, 1<<12);
										polozaj++;
										break;
									case 5:
										SET_BIT(GPIOG->BSRRH, 1<<14);
										SET_BIT(GPIOG->BSRRL, 1<<11);
										polozaj++;
										break;
									case 6:
										SET_BIT(GPIOG->BSRRH, 1<<13);
										SET_BIT(GPIOG->BSRRL, 1<<10);
										polozaj++;
										break;
									case 7:
										SET_BIT(GPIOG->BSRRH, 1<<12);
										SET_BIT(GPIOG->BSRRL, 1<<9);
										polozaj++;
										break;
									case 8:
										SET_BIT(GPIOG->BSRRH, 1<<11);//vgasnemo 11
										SET_BIT(GPIOG->BSRRL, 1<<8);//prizgemo 8
										polozaj++;
										break;
									case 9:
										SET_BIT(GPIOG->BSRRH, 1<<10);
										SET_BIT(GPIOG->BSRRL, 1<<7);
										polozaj++;
										break;
									case 10:
										SET_BIT(GPIOG->BSRRH, 1<<9);
										SET_BIT(GPIOG->BSRRL, 1<<6);
										polozaj++;
									 break;
									case 11:
										SET_BIT(GPIOG->BSRRH, 1<<8);
										polozaj++;
										break;
									case 12:
										SET_BIT(GPIOG->BSRRH, 1<<7);
										polozaj++;
										break;
									default:
										SET_BIT(GPIOG->BSRRH, 1<<6);
										polozaj = 1;
										break;
										}

		}

	}
}
